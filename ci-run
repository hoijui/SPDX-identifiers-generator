#!/usr/bin/env bash

# SPDX-FileCopyrightText: 2021 - 2025 Robin Vobruba <hoijui.quaero@gmail.com>
#
# SPDX-License-Identifier: Unlicense

# Exit immediately on each error and unset variable;
# see: https://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/
set -Eeuo pipefail
#set -Eeu

script_dir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")

BIG_REPO_CLONE_URL="https://github.com/spdx/license-list-XML.git"
TEXT_LICENSE="CC0-1.0"
AUTHOR_NAME="Robin Vobruba"
AUTHOR_EMAIL="hoijui.quaero@gmail.com"
AUTHOR="$AUTHOR_NAME <$AUTHOR_EMAIL>"
CI="${CI+true}"
if [ -z "$CI" ]
then
	CI="false"
fi

proj_dir="$script_dir"
big_repo_dir="$proj_dir/build/big"
small_repo_dir="$proj_dir/build/small"
small_slug="hoijui/SPDX-identifiers"
gen_slug="${small_slug}-generator"
licenses_file="$small_repo_dir/licenses.csv"
exceptions_file="$small_repo_dir/exceptions.csv"
init=false
push=false

function print_help() {

	echo "Creates a history of the SPDX license identifiers."
	echo "This script is designed to work both on a local machine"
	echo "and on CI (specifically 'Github Action')."
	echo
	echo "More concretely, this does:"
	echo
	echo "1. Clone/fetch the repo (\"big\"):"
	echo "   $BIG_REPO_CLONE_URL"
	echo "   at '$big_repo_dir'"
	echo "2. Clone the generated repo (\"small\") from its remote,"
	echo "   or create a new repo if --init was provided,"
	echo "   and it does not yet exist locally at"
	echo "   '$small_repo_dir'"
	echo "3. Ensures there is one commit (and tag) in \"small\""
	echo "   for each version tag in \"big\" (using the original dates),"
	echo "   containing the single column CSV files '$licenses_file' and '$exceptions_file',"
	echo "   each containing a simple, sorted list of the the license- (respectively exception-) identifiers"
	echo "	 in \"big\" at the time of the release."
	echo
	echo "Dependencies:"
	echo "* git"
	echo "* reuse (optional)"
	echo
	echo "Usage:"
	echo "         $(basename "$0") [OPTIONS]"
	echo "Options:"
	echo "          -i, --init    Initialize a new repo,"
	echo "                        instead of fetching from the remote and extending that one"
	echo "          -p, --push    Push the generated repo to its origin in the end"
	echo "          -h, --help    Show this help message"
}

function echo_readme() {
	echo "<!--"
# REUSE-IgnoreStart
	echo "SPDX-FileCopyrightText: $(date +'%Y') $AUTHOR"
	echo
	echo "SPDX-License-Identifier: $TEXT_LICENSE"
# REUSE-IgnoreEnd
	echo "-->"
	echo
	echo "# SPDX Identifiers"
	echo
	echo "[![REUSE status]("
	echo "    https://api.reuse.software/badge/github.com/$small_slug)]("
	echo "    https://api.reuse.software/info/github.com/$small_slug)"
	echo
	echo "This repo contains a simple list of all [SPDX license identifiers](licenses.csv),"
	echo "plus one of all the [exceptions](exceptions.csv) to these licenses."
	echo "The whole repo is generated by extracting data from [license-list-XML](https://github.com/spdx/license-list-XML),"
	echo "just like its bigger sibling [license-list-data](https://github.com/spdx/license-list-data),"
	echo "which contains _a lot_ more data."
	echo "The code that generates this repo can be found at [$gen_slug](https://github.com/$gen_slug)."
	echo
	echo "The \`master\` branch of this repo will always correspond"
	echo "to the latest release of the original repo."
	echo "You may NOT assume, as is commonly the case,"
	echo "that the history of this repo remains in-tact."
	echo "To the contrary, it is highly likely that the whole history"
	echo "will be regenerated at any moment."
	echo "The data can be found in the form of single column CSV files without a header row,"
	echo "or in other words, a text file with one identifier per line."
	echo
	echo "## Licensing"
	echo
	echo "While a lot of the data in the repo we extract the SPDX identifiers from"
	echo "is under different licenses, as it originates from various other places,"
	echo "the SPDX and exception identifiers themselves are provided under CC0-1.0 by SPDX."
	echo
	echo "This repo uses both the [REUSE](https://reuse.software/) way of indicating licenses"
	echo "(note the LICENSES folder in this repo),"
	echo "and the less precise but more common way of having a single LICENSE file,"
	echo "as this is more commonly supported and understood, both by humans and machines."
	echo
}

function echo_dot_license() {
# REUSE-IgnoreStart
	echo "SPDX-FileCopyrightText: $(date +'%Y') $AUTHOR"
	echo
	echo "SPDX-License-Identifier: $TEXT_LICENSE"
# REUSE-IgnoreEnd
}

function construct_origin_url() {
	gh_access_token="${GITHUB_TOKEN:-}"
	if [ -z "$gh_access_token" ]
	then
		gh_user="git@"
		gh_clone_url="${gh_user}github.com:${small_slug}.git"
	else
		gh_user="x-access-token:${gh_access_token}@"
		gh_clone_url="https://${gh_user}github.com/${small_slug}.git"
	fi
	echo "$gh_clone_url"
}

function setup_repo() {
	mkdir -p "$small_repo_dir"
	git -C "$small_repo_dir" init
	gh_clone_url="$(construct_origin_url)"
	git -C  "$small_repo_dir" remote add origin "$gh_clone_url"
}

function initial_commit() {
	# Creates the README.md
	readme="$small_repo_dir/README.md"
	echo_readme > "$readme"

	# Creates our two content files in CSV format
	touch "$licenses_file"
	touch "$exceptions_file"
	for file in "$licenses_file" "$exceptions_file"
	do
		echo_dot_license > "${file}.license"
	done

	# `git add`s the files generated so far
	git -C "$small_repo_dir" add \
		"$licenses_file"* \
		"$exceptions_file"* \
		"$readme"

	# Creates our license files
	if which reuse > /dev/null
	then
		# This fails because of a bug in the reuse tool (fixed in PR: https://github.com/fsfe/reuse-tool/pull/430):
		# reuse --root "$small_repo_dir/" download --all
		# reuse --root "$small_repo_dir/" lint
		cd "$small_repo_dir"
		reuse download --all
		reuse lint
		cd "$proj_dir"
	else
		mkdir -p "$small_repo_dir/LICENSES"
		cp \
			"$proj_dir/LICENSES/${TEXT_LICENSE}.txt" \
			"$small_repo_dir/LICENSES/"
	fi
	cp \
		"$small_repo_dir/LICENSES/${TEXT_LICENSE}.txt" \
		"$small_repo_dir/LICENSE"
	# `git add`s our license files
	git -C "$small_repo_dir" add \
		"$small_repo_dir/LICENSE*"

	# Commits everything
	git -C "$small_repo_dir" commit \
		-m "Initial commit" \
		> /dev/null
}

function list_xml_file_names() {
	dir="$1"
	find "$dir" -maxdepth 1 -name "*.xml" \
		| sort --version-sort \
		| while read -r file_path
	do
		file_name="${file_path#$dir/}"
		ident="${file_name%.xml}"
		echo "$ident"
	done
}

function git_date() {
	# this could be a SHA or a branch name
	rev="$1"
	# this should be either "a" (for author) or "c" (for committer)
	date_type="$2"

	git -C "$big_repo_dir" show --no-patch --oneline --format="%${date_type}I" "$rev"
}

function git_tag_date() {
	tag="$1"
	git -C "$big_repo_dir" for-each-ref --format '%(creatordate:iso-strict)' "refs/tags/$tag" --sort=taggerdate
}

function make_rev() {
	rev="$1"
	is_tag="${2:-false}"

	echo "Making $rev ..."

	git -C "$big_repo_dir" checkout "$rev" 2> /dev/null
	GIT_AUTHOR_DATE=$(git_date "HEAD" "a")
	GIT_COMMITTER_DATE=$(git_date "HEAD" "c")
	export GIT_AUTHOR_DATE
	export GIT_COMMITTER_DATE
	echo "    author date:   $GIT_AUTHOR_DATE"
	echo "    committer date: $GIT_COMMITTER_DATE"

	list_xml_file_names "$big_repo_dir/src" > "$licenses_file"
	list_xml_file_names "$big_repo_dir/src/exceptions" > "$exceptions_file"
	git -C "$small_repo_dir" add \
		"$licenses_file" \
		"$exceptions_file"
	if git -C "$small_repo_dir" commit --allow-empty -m "Release $rev" > /dev/null \
		&& $is_tag
	then
		GIT_AUTHOR_DATE=$(git_tag_date "$rev")
		GIT_COMMITTER_DATE="$GIT_AUTHOR_DATE"
		export GIT_AUTHOR_DATE
		export GIT_COMMITTER_DATE
		echo "    tag date:      $GIT_COMMITTER_DATE"
		git -C "$small_repo_dir" tag -a -m "Release $rev" "$rev"
	fi
}

# Calls `make_rev` if the revision is not yet present,
# otherwise does nothing.
function ensure_rev() {
	rev="$1"
	is_tag="${2:-false}"

	echo
	# If rev is not a tag, or the tag does not yet exist
	if ! $is_tag || [ -z "$(git -C "$small_repo_dir" tag -l "$rev")" ]
	then
		make_rev "$@"
	else
		echo "Skipping $rev (already exists)"
	fi
}

# read command-line args
POSITIONAL=()
while [[ $# -gt 0 ]]
do
	arg="$1"
	shift # past argument

	case "$arg" in
		-i|--init)
			init=true
			;;
		-p|--push)
			push=true
			;;
		-h|--help)
			print_help
			exit 0
			;;
		*) # non-/unknown option
			POSITIONAL+=("$arg") # save it in an array for later
			;;
	esac
done
set -- "${POSITIONAL[@]}" # restore positional parameters

if ! [ -e "$big_repo_dir" ]
then
	mkdir -p "$(dirname "$big_repo_dir")"
	git clone "$BIG_REPO_CLONE_URL" "$big_repo_dir"
fi

git -C "$big_repo_dir" fetch
git -C "$big_repo_dir" rebase origin/main

# Makes sure we have at least a basic "small" repo
# to mirror the releases of the "big" repo to
if [ -e "$small_repo_dir" ]
then
	if $init
	then
		>&2 echo "ERROR: You chose to --init a new repo,"
		>&2 echo "ERROR: but the target-dir already exists: '$small_repo_dir'"
		>&2 echo "ERROR: Consider not to --init, or removing the dir with:"
		>&2 echo "ERROR: rm -Rf \"$small_repo_dir\""
		exit 1
	else
		git -C "$small_repo_dir" fetch
		git -C "$small_repo_dir" rebase origin/master
	fi
else
	if $init
	then
		if $CI && [ -z "${GITHUB_TOKEN:-}" ]
		then
			>&2 echo "ERROR: You seem to be running on CI, but the env var GITHUB_TOKEN is not set!"
			exit 1
		fi

		setup_repo
		initial_commit
	else
		gh_clone_url="$(construct_origin_url)"
		mkdir -p "$(dirname "$small_repo_dir")"
		git clone "$gh_clone_url" "$small_repo_dir"
	fi
fi
if $CI
then
	git -C "$small_repo_dir" config user.name  "$AUTHOR_NAME"
	git -C "$small_repo_dir" config user.email "$AUTHOR_EMAIL"
fi

git -C "$big_repo_dir" tag \
	| sort --version-sort \
	| while read -r tag
do
	# HACK This check is required (as of 24. October 2021) because of the extraneous/wrongly-named tag '3.3' (the correctly named 'v3.3' also exists)
	if [[ $tag = v* ]]
	then
		ensure_rev "$tag" true
	fi
done
#ensure_rev "master" false

if $push
then
	git -C  "$small_repo_dir" push origin --tags master
fi
